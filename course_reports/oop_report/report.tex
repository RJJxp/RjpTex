\documentclass[a4paper,16pt,UTF8]{article}
    % 宏包的使用
    \usepackage{ctex}
    \usepackage{verbatim}
    \usepackage{graphicx}
    \usepackage{upgreek}
    \usepackage{longtable}
    \usepackage{geometry}
    \usepackage{graphics}
    \usepackage{booktabs}

\begin{document}

    \title{\Huge 面向对象程序设计 课程感想}
    \author{指导教师 \quad 张绍明\\
            1551127 \quad 任家平}
    \date{}
    \maketitle

    \section{\LARGE 前言}

    一开始是打算慢慢写这份感想，将其以报告的形式展现出来，把所有关于代码的细节和思考都写进去，让报告的内容丰富饱满一些。也当做是自己的一份总结，可这些细枝末节早已在日常的代码笔记里面写过了，直接复制黏贴有点不给这份报告面子，充其量是多一些字数。多花些时间细致的把笔记整理，把具有教育意义的bug重现，誊抄在报告上，极为花费时间。斟酌了一小会，还是不用这么麻烦，直接从较为宏观的角度写写心得体会和感想。现在的时间都放在看线性代数，RGandML，设计模式上面。

    \section{\LARGE 正文}

    很开心，本学期的这门课，没有偷懒也没有眼高手低，所有编程任务都认认真真完成，在课堂上思路大致听懂，回去琢磨琢磨推敲推敲，把细节部分添枝加叶补充完整，系统的看一遍老师的代码，待脑回路形成，关掉老师的项目，敲自己的代码。花的时间多了，自然知识点就熟练了，程序也就写出来了。

    写了一个学期的程序，不由得感慨，面向对象程序设计才是真正实用的编程技术，然而课程设计并没有把这门课放到大三下，个人感觉是晚了点。平常和哥们几个吐槽，大家也是这么想。不过一个人冷静下来想了想，就算放到了大二，没有长时间的面向过程的编程经历，没有培养出对面向过程编程的极度恶心与反胃，今日也不会对这门课有如此的热情和热爱。所以也没必要过于偏激或者悔恨，现在的永远是最好的。

    \subsection{\Large 课程内容回顾}
    
    课程内容分为两大部分。第一部分是cpp的基础知识点回顾，第二部分是设计模式的学习。

    第一部分说是cpp基础知识点的“回顾”，事实上就和考试前某些课程的“复习”一样。说是复习，事实上是预习，因为从开学到考试前从来没有翻过书。cpp知识的回顾，顾名思义，对我，或者对我们班里的大多数同学来说，是cpp的重新来过。大一上过的计算机课，当时也有一门cpp的公选编程课，现在想想，貌似当时对cpp的特性只有概念上的介绍，提了一下，cpp是有多态，继承，封装等等的特性。平常的cpp作业也就都是基于c语言。但那毕竟是两年前的课了，上这个课之前，对cpp的概念是全忘光了，所以相当是0基础，也是辛苦了张老师。

    cpp的基础知识首先是带有欺骗性的参数传递，之后有三个构造函数，多态，深拷贝和浅拷贝和生成自己的dll和lib。该部分是在VS环境下实现。
    
    \begin{enumerate}
        \item 三个构造函数分别是默认构造函数或一般构造函数，赋值构造函数，拷贝构造函数。在区分赋值构造函数和拷贝构造函数是看等号左边的参数有没有被创建过，若被创建过，则为赋值构造函数，否则为拷贝构造函数。但构造函数应该不止这三种，不过这三种也确实包括了大多数构造函数。

        \item 多态之前需要搞清楚父类子类之间的指针能否互相指代，结论是可以用父类指针指向子类指针，这为多态打下了基础，其实现基类子类同名函数的之前加上限定词virtual，讲多态时还穿插动静态转换的概念。
        
        \item 深浅拷贝指的是内存中变量是否指向同一地址，浅拷贝则拷贝出的变量是指向原地址，此时改变拷贝变量的值，则原始值也会受到影响，深拷贝则恰恰相反,对拷贝变量新开辟一片内存空间，那么对拷贝变量的改变并不会影响到原始变量。但是并不意味着深拷贝一定比浅拷贝好，两者的优劣应视情况而定。当数据量比较大时，优先选择浅拷贝，当不需要改变数据时，则选择深拷贝。

        \item 生成自己的lib只需要在需要导出的类命前加一段 \emph{$ \_declspec(dllexport)$} 即可导出\emph{A.dll A.exp A.lik A.lib A.pdb}拿出其中的 $A.dll$和$A.lib$外加自己的头文件和说明文件即可让客户使用。

    \end{enumerate}

    课堂第二部分内容是在QT环境下设计模式的学习，该部分是课堂的重头戏，是对第一部分cpp基础知识的巩固也是写代码中思维的提升与格式的规范。
    
    课堂所讲到主要的设计模式有$observer$, $factory$, $abstract factory$, $singleton$, $shadow$, $builder$, $prototype$, $proxy$, $flyweight$, $command$。还有一些虽没有讲，但已经隐含在所写的程序中，如$adaptor$, $bridge$, $composite$, $decorator$, $facade$设计模式。

    \begin{center}
        \begin{itemize}
            \item 为创造对象服务的设计模式
            \begin{description}
                \item[$factory$]正如现实世界中的工厂一般，生产产品，只不过此时代表设计模式时，目的在于解决多态子类类型比较多时，并用父类指代所生成的子类
                \item[$singleton$]使用静态成员变量，实现数据在多窗体的获取游走，可以和factory设计模式联合使用。在shpReader的程序里，shapes的全局变量使用了该设计模式
                \item[$builder$]将复杂对象的构建和它的表示相分离，使同样的构建过程可以有不同的表达。如程序中的map类中，先有northpointer,grid,scaler等等是map的表示，但是构建是在mapbuilder中，用户最终通过director调用builder的接口，选择自己需要的mapbuilder完成map的构建。
                \item[$prototype$]通俗的说，就是复制。类A需要调用数据B，但是类A又不能初始化或者实例化数据B，所以需要在数据B的类中写clone函数，在类A需要调用时，复制一份数据给A。              
            \end{description}

            \item 为优化结构的服务的设计模式
            \begin{description}
                \item[$adaptor$]类A和类B不适配，但是A需要用到B才可以实现需要的功能，这时可以设置一个类C，作为A和B的接口。具体的实现方法可以是让C继承A，并在C中完成B的实例化
                \item[$bridge$]将抽象的部分与其实现步步分离，使它们可以独立变化。比如map的组件组成map，再由builder构建map，最终由director返回map，就是bridge很好的例子。map--mapbuilder--mapdirector，不同的map对应不同的builder和director，便可灵活地实现各种map的构建。
                \item[$composite$]整体部分组合结构，shape和shapes就是很好的例子，在每个shape的绘制中，都需要一个box，在需要显示多个shape的时候，尤其是同一地物的不同shape时，需要统一box。这时只需要由composite设计模式，将所有shape组合成shapes统一box。不单单是box的统一，绘图绘制一个多个shape也就是一个shapes，它在逻辑的抽象层面就应该是一个shapes。
                \item[$flyweight$]蝇量级设计模式，通俗讲，就是list如果有太多重复和顺序，只存储list对应的set。具体实现是通过在factory中加上set集,将factory设置为dataset的私有变量。这样在添加数据的时候，可通过判断其变量是否在set集出现过，来选择是新建还是返回已有。对于简单的int数组，也是如此，只不过更加简单了些。
                \item[$proxy$]代理模式，在课程的程序中，为了使用智能指针，用DatasetPtr代理shape,通过设置refcount变量，等号运算符重载会使refcount++，记录dataset的引用次数。
            \end{description}

            \item 为响应行为的服务的设计模式
            \begin{description}
                \item[$observer$]来监控对象的变化，传递信号告诉监控者有变化，待监控者做出响应，会在理解部分细谈，此处不赘述。
                \item[$command$]对象行为设计模式。使用模板类响应其他对象的函数。也会在理解部分细谈，此处不赘述。
            \end{description}
        \end{itemize}
  
    \end{center}
    
    虽然写了很多设计模式，但是总会有几个的理解远没有其他深刻，比如builder模式和brige模式。对于map来说，builder模式是着重强调抽象部分与实现的分离，即map的抽象（个人觉得此处的抽象不是抽象基类的抽象，而是逻辑层面思维层面的抽象）类中并没有buildmap之类的函数，map的build动作在mapbuilder里面，通过mapdirector整合。而bridge则是强调抽象和实现的步步分离。先有地图要素，再有地图，再有mapbuilder，之后再有mapdirector。很难去评判究竟在map的build动作里面，是builder设计模式起的作用大，还是bridge设计模式起的作用大，或者decorator设计模式起的作用大，因为两者确实都让map的build动作变得灵活，可以由一个build动作而衍生出不同的map类。

    \subsection{\Large 肤浅的理解}

        经历了面向对象的编程，渐渐心中有一种不可名状的想法。越发觉得程序的构架是对现实生活的抽象，对客观事物的抽象，或者说，越高级的设计模式越是能反应需求的本质，只不过实现的载体变为了计算机。

        拿observer设计模式来举例。在课程的程序中共经历了三个阶段。
        \begin{enumerate}
            \item shapes中直接有QMainwindow类型的observer变量，并通过setOb将mainwindow赋值给observer变量
            \item 设置shpObserver类，并让MainWindow继承shpObserver类，通过setOb将mainwindow赋值给observer变量
            \item 使用command设计模式，在shapes中设置command变量，通过模板函数，将command设置为mainwindow的updatewhenshapeschange。通过此种方法，直接实现observer模式
        \end{enumerate}

        细细思考这三个阶段的变化，第一阶段直接设置qmainwindow类型变量，是已知我的监视者是mainwindow，但是需求的本质仅此而已吗？提出问题，万一我的observer不是mainwindow，而是shpview或者其他的窗体类型，进而在思维上抽象，反应在代码上则为有了shapesobserver和观察者的多继承。

        记得老师在最后一节课上反问大家，有谁觉得这种多继承实现observer模式不好？我心里像是憋了什么东西，但毕竟对比第一阶段的observer，这个多继承是在太方便了,而且它背后隐藏的思维方式非常有趣，挺纳闷怎么能想到如此神奇的东西。多继承的observer可以忽略窗体的类，而且本质是类的继承，也就是类的转化，非常灵活，但是毕竟穿梭在各个类之间，唯一缺点就是乱，现在只继承一个shpObserver类可能没有问题，只有一个updatewhenshapeschange函数，还能理得清，但多继承的多了，就容易混乱。当时只是隐隐觉得不对，并没有说什么，果然command设计模式又带来了天翻地覆的改变。

        不需要将observer的er具体化为某个窗体类型，只需要知道shapes在notify时，调用了observer的哪一个函数，将这个函数写成一个命令，存入shapes，在notify时，调用该命令即可达到同样的效果。
        
        因为你需求的本质是observer的更新函数，之所以能产生command设计模式的observer是因为对自己的需求的认识更加清晰。从开始认为的mainwindow和shpobserver，他们的需求是基于observer对象，而command模式将对象推翻，直接瞄准updatewhenshapeschange函数。在我看来，产生此种变化的原因是对该问题的理解更深，抽象的更彻底。

        思维就这样建立起来被推翻，建立起来再推翻。一浪高过一浪。

        在写多继承的observer时，曾在脑海里思考过一个问题，如果设计的mapwindow要随着shapes添加而更新，那么mapwindow也是shaObserver的子类，如果shapes有多个observer，怎么办？可以通过vector变量，将setOb变为addOb，但是这样的假设条件是在所有observer不会被销毁的情况下，如果很多窗体都像mapwindow一样，要被销毁，那么在新加shape时，需要更新，结果遍历observer的vector时，有些observer变成了null，结果必然是报错的。也就是observer的vector是需要和将被关闭的窗体的关闭事件进行关联，再去各种判断，减少vector的长度，这就变得很麻烦。

        使用多继承是可以解决该问题，但如果observer的类太多，多继承太多，虽然能解决该问题，但考虑到其他observer也会多继承其他类，在未知的情况下，不知道会带来怎么样的影响。command设计模式虽然没有多继承的麻烦，但是它也需要窗体存在才能用模板调用其函数，在notify时也会遇到，关闭的窗口会使command变为空，但在notify中依然会调用。至少在我的狭隘的思考中，command设计模式也没有能解决该问题。还是要抽空请教老师。

        从这个天马行空的问题中跳出来，继续关于抽象的讨论。
        
        涉及到此话题的程序还有composite设计模式，shape到shapes的转换，就是每个shape当成一个图层做处理，那么shapes则理所当然地成为了一个图。这和composite设计模式的理念恰恰相符。factory设计模式和prototype设计模式也是如此，所以特殊到一般，我不是非常理解的builder设计模式是不是也是如此呢？我之所以理解不了大概是我不到达不了它抽象的高度。

        设计模式是对实际问题解决方案的高度抽象，总算是真正体会到了它的深刻含义。


    \subsection{\Large 小结与致谢}

        说来惭愧，老师给我的设计模式书，只是大致的看了看思路，细节倒是茫然不知，里面动机部分举的例子全是工程开发的实例，对于我这种菜鸟来说，读起来颇为吃力，于是乎就变成了看完设计模式的意图和别名，动机能看看，看不懂直接跳到适用性和结构部分。大致能理解，但还是需要抽出时间来精读一番。

        开始本学期课程的时候，猛然醒悟。发现自己大二下和大三上写的程序，除了巩固复习了专业知识以外，对于程序学习也仅仅是熟悉了语法，对于如何设计一个大项目，如何写一个大程序，没有任何的帮助。我有强迫症，对于函数的结构体非常偏执。我认为函数所用到的变量都应该在函数头的传入参数中，这样看起来比较整齐。在大三上的大地测量的编程中，计算高斯投影坐标。一些参数比如椭球参数，是全局变量，计算坐标的函数还需要传入其他的参数，计算后返回xy坐标。所以在函数体中如果突然出现了一个不认识的变量，你还需要去看它是全局变量还是在函数实体内定义的变量，程序非常混乱。一气之下，就把所有全局变量转移到函数体内部，但是每个计算函数都需要椭球参数，所以一些变量的重复定义又让函数臃肿不堪。

        现在学了面对对象的程序设计，仔细地思索了两者的区别。在一个类中，它所有的变量，私有的也好，公有的也好，对于cpp文件，他们都是全局变量。也就是说面向对象中类的变量，如果按照面向过程的逻辑思维看，它们的作用域是整个cpp。仅以变量的作用域来区分面向对象和面向过程，不应该有什么区别，但在类中敲代码确实感觉思路会清晰很多。可能经过抽象，潜意识里面有了对象的概念，所以很方便就记住了。

        当然面向对象的优势更多还是在大项目的编写上，一个大功能实现的基础是多个小功能的完善。比如图形操作界面，缩放平移之类的操作要响应鼠标事件，这时需要设置各种bool类型的变量来判断是否需要平移或者缩放。就大三上写这钟程序（面向过程）全局变量都有4-5个，虽然写出来了，但写的时候自已都有些晕头转向。然而这才是实现一个小小小小小小的功能，如果对于大项目的话，我估计写的人能勉勉强强大致不糊涂，要让其他人看懂，难度很高。面向对象的程序设计对此问题可以迎刃而解，我只管给你实现的功能，至于怎么实现，是客户不需要管的，封装性是写出大项目的关键。全局变量严重破坏了程序和函数的封装性，所以除非万不得已，不会再去碰全局变量。

        一开始上课的时候，感觉自己进步很大，对课堂所讲设计模式也比较崇拜。冷静之后回想自己都问过哪些比较有教育意义的问题，无非就是内存泄露，初始化列表，shadow模式的使用条件，代理模式的运算符重载部分，现在看来，也就后两个问题有些水平，前两个完全是因为底子太差，需要多看见c++prime这类书。而且拜读了设计模式的书，发现课程的程序中虽然实现了很多设计模式，但实现都是浅尝辄止的实现，因为shpreader的需求过于简单，如果是复杂的项目，掂量掂量自己，还是有点悬。当然进步很大，无奈底子差，还不够。

        感谢张老师的认真授课，学到了真正的技术，更重要的是找到了方向，未来显得不是那么不可捉摸。诚如老生常谈，学院的课程设计可能出了点问题，两年里面泡在传统测绘的染缸里，愤懑不已。暑假自己去省测绘局实习探了探待遇问题，惨不忍睹。倒不是自己只在意薪资，只是如果自己干的事情太无趣，能在意的也只有薪资待遇。
        
        现在不同了，找到了想干的事情，活在梦里，开心。从之前死气沉沉，到现在干劲很足，想看bishop的书，担心对线性代数的理解太差，从网上找了本不错的英文教材$Linear Algebra Done Right$，不过估计后面还要补一补矩阵方面的书。总之就是学习，然后锻炼。乐此不疲。

        总之感谢。
        
        双手敬上。

        % 唯一后悔的是太过烂漫，绩点4.32，在保研的边界徘徊。有时会稍有悔恨，如果认真一点，如果和大家一样功利一些$\cdots$，不过真的能重来，我还是我,只会再次把权威踩在脚底下，更加疯狂地我行我素，悔意之类的东西便瞬间烟消云散。

        % 老师点醒我的方向不仅仅是想从事的行业，更重要的是点醒了我内心中一直以来的疑问。
        
        % \emph{我，究竟要成为什么样的人？}

        % 天天疲于应付作业，放纵，考试也从来不认真复习，随随便便拿个良勉勉强强得个优也就过去了，也不在意绩点，一切皆佛系，爱如何如何。因为对医学感兴趣，我大三上整个在选修课上花费的精力都可以和专业课不相上下。在
        




\end{document}