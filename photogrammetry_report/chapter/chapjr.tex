\chapter{贾锐个人实习报告}

\section{实习内容}

\subsection{外业测量} 

\paragraph{基本过程}

在这一阶段，我们小组根据老师所划测区进行了量测工作。体会了从影像上面选取点、之后到实地进行量测的过程。在量测过程中，我们利用支导线布点的方式提高了量测精度。除此之外。我们采用在两个站观测同一点，来进行所量测点的精度检校。

\paragraph{完成方式} 小组一同出工，各自测取各自点。

\subsection{像点坐标量测} 

\paragraph{基本过程}

这部分实习中，我们小组根据我们的测区选择了63、64两幅影像，六个人分工各自量取6对同名点，并且进行点之记。在这个过程中，我熟悉了PhotoShop的操作。

\paragraph{完成方式} 
完成所属部分6对同名点像素坐标选定以及点之记。

\subsection{内定向--相对定向} 
\paragraph{基本过程}在这一实习过程，根据老师所给的相机camera文件，我首先求取了内定向参数。之后利用内定向参数开始编写相对定向程序。首先根据老师所给公式进行编写，之后发现迭代次数很高，在后续课程中，根据与同学商讨、自行修正对于程序进行了完善，对于所用数据源像素点进行了取舍。最终迭代了4次完成了相对定向，求得了相对定向元素。
\paragraph{完成方式}独立完成。
\paragraph{数据源}
内定向结果，小组内经过剔除之后的同名点以及其他小组的一些点，总共11对。

\subsection{Kinect Fusion系统建模} 

\subsubsection{基本原理}
根据实验中的直观感受及课外查阅，我了解了Kinecr Fusion的操作原理。

KinectFusion使用户可以手持Kinect移动，仅用Kinect的深度信息来追踪传感器的3D姿态，实时重建室内场景的详细3D模型。

Kinect运用结构良好的光学技术形成实时的实物场景的离散测量点深度图。这些测量值可以投影变换到一系列离散3D点（或点云）。虽然与别的可商用的深度摄像机所提供的深度数据相比有优势，Kinect的噪声也会引起深度测量值波动，深度图包含没有读到的“空洞”。

系统实时的从移动着的Kinect摄像头中获得深度数据，实时创建一个高质量，几何精确的3D模型。用户手持标准kinect，可在室内任意移动，并在几秒内重建出实物场景的3D模型。系统连续跟踪标定摄像头姿势的六个自由度，把场景的不同新视角融进一个global surface-based展示。一个新的GPU流水线使精确的摄像头跟踪和实时交互速度的表面重建成为可能。随着用户的移动，新摄入的物理场景视角都被融入同一模型中，因此，重建的模型就随着新的测量值的加入而不断完善细节。孔洞慢慢被填平，模型也逐渐趋于完整。

\subsubsection{算法流程}
\begin{enumerate}
\item 深度数据处理，是将传感器原始的深度数据转换成3D点云，得到点云中顶点的3维坐标和法向量； 
\item 相机跟踪：将当前帧3D点云和由现有模型生成的预测的3D点云进行ICP匹配，计算得到当前帧相机的位姿 
\item 点云融合：根据所计算出的当前相机位姿，使用TSDF点云融合算法将当前帧的3D点云融合到现有模型中。 
\item 场景渲染：是使用光线跟踪的方法，根据现有模型和当前相机位姿预测出当前相机观察到的环境点云，一方面用于反馈给用户，另一方面提供给b进行ICP匹配。 
\end{enumerate}

\subsection{前方交会--绝对定向}
\paragraph{基本过程}
利用前方交会的方式求取出像点的模型坐标，算出各点上下视差，剔除视差大的点，选取小点进行实验。利用剩余点的模型坐标以及地面物方坐标，获得物方坐标系与模型坐标系的七个转化参数。完成绝对定向。最终利用11对点进行了3次迭代之后求取了转换参数。
\paragraph{完成方式} 
独立完成程序，在之后剔点时参考了小组最终选择的点。
\paragraph{数据源}
全班提出后剩余的11对点。

\subsection{点位精度的评定}

根据求出的绝对定向坐标，和真实测量出的地面坐标进行比较，求出了每个点XYZ的点位误差。以此也可以反应绝对定向是否成功。\\
我求得的结果为: X的中误差=0.124881, Y的中误差=0.215042, Z的中误差=0.239378,可以看到，精度在接受范围。证明绝对定向成功。
\subsection{调绘} 
\subsubsection{调绘要求}
在调绘之前，我查阅了调绘中需要注意的地方:

\begin{itemize}
\item 地物地貌的调绘要连续进行，避免调绘不连贯和遗漏。
\item 地理名称注记过密时，可适当取舍。
\item 调绘工作应按照国家标准的地形图图式进行，说明性质的注记应采用“简注表”，不得任意命名。
\item 调绘要按照实地情况严格进行，不得伪造、篡改。
\end{itemize}

\subsubsection{调绘过程}
在进行调绘前我先拍摄了同济大学平面图，之后对照平面图对于全学校进行了走访，确定了每幢楼的层高，大致估算了路宽，确定了每幢楼的材质以及用途。

\section{实习中所遇问题及解决}
\subsection{问题及解决}
  \begin{itemize}
\item 问题：实地量测时我的点在不同站间误差大；\\
      解决：之后进行了二次测量。
\item 问题：相对定向迭代次数很多，起初要进行十次以上；   \\
       解决：对于公式进行修正、对于所用同名点进行选取。最终选择35对。
\item 进行前方交会时，发现z坐标算出为-2000，以为算错；  \\
       解决：经过思考以及与我组同学陈晨讨论，明白这是正确的。
\item 问题： 绝对定向无法收敛；\\
      解决： 起初只选择了4对q最小的点进行绝对定向，但是最终迭代1756次不能收敛。 之后意识到需要增加点数，再次重新对于全班的点进行选取，选择了11对点。迭代3次完成。与小组其他成员结果相近。
\item 问题：调绘时候对于地点不能精确记录； \\
      解决：学到了更有条理的利用“草图”、标号代替文字 进行记录的方式。
\end{itemize}

\section{心得体会}

半个学期的时间一晃而过，摄影测量实习也进入了尾声。每一次的课程实习都会让我学到很多。对于书本知识的巩固、对于所学到摄影测量内容的进一步理解、实习过程中同学友谊的增进、实习过程中所遇问题的或独立或团体解决…都让我印象深刻受益匪浅。

特别是，学过摄影测量学后，对摄影测量只是一种理论的粗浅认识，局限于书本公式，而并不知道如何去运用它，也不知道要在什么场合使用。实习使我对于传统摄影测量的基本流程有了清晰的认识和切身的体会。对于利用相对定向-绝对定向求取地面点坐标的方法有了更深的体会。在编写程序时，从一开始的完全找不到头绪、看不懂老师的实验指导书，到后来看懂了指导书却在实际编程中遇到种种问题使得进度一直难以进行。特别是在进行点的剔除的时候，一开始找不到合适的方法，只是在随机剔除，经常不能收敛，以至于自觉是计算出现了问题。使得进度在很长一段时间不能推进。通过这个经历，也锻炼了我发现问题、解决问题、不随意放弃的学习能力。之后在进行前方交会程序的编写时，得到了-2000的Z坐标，又一度认为是程序出错。反复大量排查之后，经过与小组同学的讨论以及课上老师的讲解，意识到这个结果是正确的，可以继续进行。在进行绝对定向程序编写时，也遇到了一开始不能收敛的问题，发现还是自己选择的点有问题，经过对于点的改正后终于实现了结果。

通过上述亲身经历，我意识到点的质量对于我们实际进行摄影测量内业工作的重要程度。从而使得我将在未来的外业测量中各加认真，让我明白了老师们经常说的“控制点很珍贵”的真正含义。

除此之外，老师还为我们安排了关于Kinet的三维建模实习，扩宽了我们的视野，让我们不仅对传统摄影测量方法熟知，对于新兴技术也有了解。出于兴趣，课后还自行查阅了Kinect Fusion算法，拓宽了知识面。

在进行同名点的确认过程中，由于自身感觉人工量点的方式效率很低并且精度真的不高。我对与目前流行的同名点匹配方式进行了查阅，发现利用以下几种方式有利于提高效率、精度：
\begin{itemize}
\item 利用matlab进行配准。matlab中有相关的包。
\item 可以使用opencv中的开源库
\end{itemize}

另外，调绘的过程使我对于学校更加熟悉，来到同济大学已经第三年，这次调绘我才发现我对于学校其实知之甚少，很多建筑、道路完全没有过了解。是这次调绘给了我这个机会。我发现了“同济大学后勤处”所在地，发现了三好坞餐厅。。。在利用Photoshop进行标注的时候，我对于这个软件有了更加深的了解。

在小组的配合上也增进了同学友谊，在相处过程中有摩擦、也有思想的碰撞。私以为这样的经历提高了我的包容性。程序上遇到了问题，可以请教组内同学，知识上有不理解的地方，也有同学帮我解答。大家齐心协作又各自分工，各自高质量独立完成自己的任务。

在老师安排的校友讲座上，使得我对于摄影测量在实际的生产中目前的应用情况以及方法有了清晰的认识。实现了课本--实习--生产的接轨。听了校友讲述的关于深度学习和神经网络的人工智能方面的新技术后，出于好奇我进行了粗浅查阅，经过一段时间的摸索我发现尽管有了新的进行摄影测量的方式，但是新技术仍然存在很多局限。它不能适应多变的、大范围的环境，它需要大量的控制点，它易受到气候影响等。这就使得在例如火星探测这样的特殊场合，不能进行使用。在很特殊的场合，在新技术不能使用的时候，传统摄影测量的方法依旧值得运用。并且在很多新技术的内核中，都有基础知识的充斥，我们作为优秀的大学生，应当做到“知其然，并知其所以然”。踏踏实实，一步一个脚印，把步子走稳走实。

最后，特别感谢老师的认真指导，因为您在班上公开解答了很多我遇到的问题，才使得我的实验可以进行下来。您让我们有了一个很踏实的实习经历，这两个月的时间让我收获颇丰，相信将对我今后的学习生活大有裨益。

\section{程序集}
\subsection{内定向}

\subsubsection{内定向程序}


\begin{lstlisting}[caption=oriention.m]
function orientation()
format long
[a1,a2]=textread('camera.txt','%n%n');
a=[a1 a2];
theoreticalpositions = a(2:2:end,:);%框标的理论位置
PC = a(1:2:end,:);%框标像素坐标
L=theoreticalpositions';
L=L(:);
B=zeros(8,6);
for i=1:2:8
B(i,1)=1;
end
for i=2:2:8
    B(i,4)=1;
end
for i=1:2:8
    B(i,2)=PC(((i+1)/2),1);
end
for i=1:2:7
 B(i,3)=PC(((i+1)/2),2);
end
for i=2:2:8
    B(i,5)=PC((i/2),1);
end
for i=2:2:8
    B(i,6)=PC((i/2),2);
end
%B=B.*(-1);
%BB=B'
X=inv(B'*B)*(B')*L;
V=-B*X+L;
v1=V(1:2:end);
v2=V(2:2:end);
qxx=inv(B'*B);
omega1=sqrt(v1'*v1)/2;
omega2=sqrt(v2'*v2)/2;

fid=fopen('Orientation_R.txt','wt');

[row,col]=size(X);
for i=1:1:row
    for j=1:1:col
        if(j==col)
            fprintf(fid,'%f\n',X(i,j));
        else
            fprintf(fid,'%f\n',X(i,j));
        end
    end
end
fprintf(fid,'%s\t','X precision：');
fprintf(fid,'%f\n',omega1);
fprintf(fid,'%s\t','Y precision：');
fprintf(fid,'%f\n',omega2);
fclose(fid);
\end{lstlisting}

\subsubsection{结果}
\begin{equation}
\begin{array}{lll}
h_0=-46.08 & h_1=0.012 & h_2=0 \\
k_0=82.944 & k_1=0 & k_2=-0.012\\
\end{array}
\end{equation}

X precision:0.000000\\
Y precision:0.000000

\subsection{相对定向}
\subsubsection{程序}

\begin{lstlisting}[caption=XDDX.m]
function xiangduiDX %相对定向
clear;
clc;
[filename,pathname]=uigetfile('相定点标.txt','选择相对定向点文件');
fid1=fopen(strcat(pathname,filename),'rt');
i=find('.'==filename);
net_name=filename(1:i-1);
nt=fscanf(fid1,'%f',1);%点对个数
f1=fscanf(fid1,'%f',1);%左片
f2=fscanf(fid1,'%f',1);%右片
f3=fscanf(fid1,'%f',[4,nt]);%4行nt列
fclose(fid1);
f3=f3';
i1=f3(:,1);
j1=f3(:,2);
i2=f3(:,3);
j2=f3(:,4);
sz=size(j2);
np=sz(1);
[filename,pathname]=uigetfile('ndx结果.txt','选择内定向参数文件');
fid1=fopen(strcat(pathname,filename),'rt');
S=textread(strcat(pathname,filename),'%f',6);
fclose(fid1);
for i=1:6
    A(i)=S(i);
   % A(i)=A(i)+1;
end
%内定向--像素坐标转成像空坐标
x1=A(1)+A(2)*i1+A(3)*j1;
y1=A(4)+A(5)*i1+A(6)*j1;
x2=A(1)+A(2)*i2+A(3)*j2;
y2=A(4)+A(5)*i2+A(6)*j2;
f=120;w1=0;
%确定初始值
fai1=0;k1=0;fai2=0;w2=0;k2=0;
X0=[fai1;k1;fai2;w2;k2];
%lim=0.0003*ones(5,1);
DX=ones(5,1);
z=-f*ones(1,np);
ct=0;%循环次数
while (abs(DX(1))>0.0003 | abs(DX(2))>0.0003 | abs(DX(3))>0.0003 | abs(DX(4))>0.0003 | abs(DX(5))>0.0003)
%计算像空辅助坐标
a11=cos(X0(1))*cos(X0(2))-sin(X0(1))*sin(w1)*sin(X0(2));
a12=-cos(X0(1))*sin(X0(2))-sin(X0(1))*sin(w1)*cos(X0(2));
a13=-sin(X0(1))*cos(w1);
b11=cos(w1)*sin(X0(2));
b12=cos(w1)*cos(X0(2));
b13=-sin(w1);
c11=sin(X0(1))*cos(X0(2))+cos(X0(1))*sin(w1)*sin(X0(2));
c12=-sin(X0(1))*sin(X0(2))+cos(X0(1))*sin(w1)*cos(X0(2));
c13=cos(X0(1))*cos(w1);
R1=[a11 a12 a13;b11 b12 b13;c11 c12 c13];
a21=cos(X0(3))*cos(X0(5))-sin(X0(3))*sin(X0(4))*sin(X0(5));
a22=-cos(X0(3))*sin(X0(5))-sin(X0(3))*sin(X0(4))*cos(X0(5));
a23=-sin(X0(3))*cos(X0(4));
b21=cos(X0(4))*sin(X0(5));
b22=cos(X0(4))*cos(X0(5));
b23=-sin(X0(4));
c21=sin(X0(3))*cos(X0(5))+cos(X0(3))*sin(X0(4))*sin(X0(5));
c22=-sin(X0(3))*sin(X0(5))+cos(X0(3))*sin(X0(4))*cos(X0(5));
c23=cos(X0(3))*cos(X0(4));
R2=[a21 a22 a23;b21 b22 b23;c21 c22 c23];
P1=R1*[x1';y1';z];
P2=R2*[x2';y2';z];
%生成误差方程
B=zeros(np:5);
B(:,1)=(-P1(1,:).*P2(2,:)./P1(3,:))';
B(:,2)=P1(1,:)'
B(:,3)=(P2(1,:).*P1(2,:)./P1(3,:))';
B(:,4)=(P1(3,:)+P1(2,:).*P2(2,:)./P1(3,:))';
%B(:,4)=-(P1(3,:)-P1(2,:).*P2(2,:)./P1(3,:))';
B(:,5)=-P2(1,:)';

L=f*(P1(2,:)./P1(3,:)-P2(2,:)./P2(3,:))';
DX=inv(B'*B)*B'*L;
X=X0+DX;
ct=ct+1;
%判断
%if (DX<lim)
 %   break;
 %end
if ct>10
    msgbox('the cycling times is more than 5','Warning','warn');
    break;
end;
X0=X;
end
fid=fopen(strcat(pathname,net_name,'result_new.txt'),'wt');
c=fprintf(fid,'%s\n','相对定向参数为');
c=fprintf(fid,'%7.6f\n',X);%X=[fai1 k1 fai2 w2 k2]
st=fclose(fid);
return
\end{lstlisting}

\subsubsection{结果}
\begin{equation}
\begin{array}{lll}
\phi_1=-0.012473 & & \kappa_1=0.028427 \\
\phi_2=0.013329 & \omega_2=-0.022502 & \kappa_2=0.036377
\end{array}
\end{equation}

\subsection{前方交会-绝对定向}

\subsubsection{程序}

\begin{lstlisting}[caption=QF\_JDDX.m]
function [retval] = QF ()
%kbpoints=xlsread('F:\octave\kbpoints.xlsx');
[FileName,PathName]=uigetfile('.txt','please choose XSZB'); %像素坐标获得的内定向结果
[x1,y1,x2,y2]=textread([PathName,FileName],'%f %f %f %f');
[filename,pathname]=uigetfile('.txt','please choose XDDX result');
 X=textread(strcat(pathname,filename),'%n','headerline、',1);


fi1=X(2);
wa1=0;
ka1=X(3);
fi2=X(4);
wa2=X(5);
ka2=X(6);

al1=cos(fi1)*cos(ka1)-sin(fi1)*sin(wa1)*sin(ka1);
 al2=-cos(fi1)*sin(ka1)-sin(fi1)*sin(wa1)*cos(ka1);
 al3=-sin(fi1)*cos(wa1);
 bl1=cos(wa1)*sin(ka1);
 bl2=cos(wa1)*cos(ka1);
 bl3=-sin(wa1);
 cl1=sin(fi1)*cos(ka1)+cos(fi1)*sin(wa1)*sin(ka1);
 cl2=-sin(fi1)*sin(ka1)+cos(fi1)*sin(wa1)*cos(ka1);
 cl3=cos(fi1)*cos(wa1);
 ar1=cos(fi2)*cos(ka2)-sin(fi2)*sin(wa2)*sin(ka2);
 ar2=-cos(fi2)*sin(ka2)-sin(fi2)*sin(wa2)*cos(ka2);
 ar3=-sin(fi2)*cos(wa2);
 br1=cos(wa2)*sin(ka2);
 br2=cos(wa2)*cos(ka2);
 br3=-sin(wa2);
 cr1=sin(fi2)*cos(ka2)+cos(fi2)*sin(wa2)*sin(ka2);
 cr2=-sin(fi2)*sin(ka2)+cos(fi2)*sin(wa2)*cos(ka2);
 cr3=cos(fi2)*cos(wa2);
 
R1=[al1 al2 al3;bl1 bl2 bl3;cl1 cl2 cl3];
 R2=[ar1 ar2 ar3;br1 br2 br3;cr1 cr2 cr3];
 p=0.6;
 l=46.08*2;
 M=(7680*0.2)/(46.08*2);
 b=l*(1-0.6)*M;
 B=[b 0 0];
 f=120;
%L_image=[kbpoints(:,1:2),-f*ones(size(kbpoints,1),1)]';
%R_image=[kbpoints(:,3:4),-f*ones(size(kbpoints,1),1)]';
L_image=[[x1,y1],-f*ones(size(x1,1),1)]';
R_image=[[x2,y2],-f*ones(size(x1,1),1)]';
i1=R1*L_image;
i2=R2*R_image;
xyzq=zeros(size(i1,2),4);
for i=1:size(i1,2),
N1=(B(1)*i2(3,i))/(i1(1,i)*i2(3,i)-i2(1,i)*i1(3,i));
N2=(B(1)*i1(3,i))/(i1(1,i)*i2(3,i)-i2(1,i)*i1(3,i));
x=N1*i1(1,i);
y=0.5*(N1*i1(2,i)+N2*i2(2,i));
z=N1*i1(3,i);
q=N1*i1(2,i)-N2*i2(2,i);
xyzq(i,:)=[x y z q]
end
q=xyzq(:,4);
%XYZ=xlsread('F:\octave\points.xlsx',1,'H3:J47');
[FileName,PathName]=uigetfile('.txt','please choose DMZB'); %像素坐标获得的内定向结果
[X,Y,Z]=textread([PathName,FileName],'%f %f %f ');

xyz=xyzq(:,1:3);
%X=XYZ(:,1:1);
%Y=XYZ(:,2:2);
%Z=XYZ(:,3:3);
fid=fopen('F:\octave\QFresult.txt','wt');
i=0;
fi0=0;
m0=0;
ka0=0;
lamda0=1;
detX=0;
detY=0;
detZ=0;  
Xg=0;
Yg=0;
Zg=0;
theta=0;
fi0=0;
om0=0;
ka0=0;
lamda0=1;
detX=0;
detY=0;
detZ=0;  
Xg=0;
Yg=0;
Zg=0;
n=length(X);
for i=1:n
  Xg=Xg+X(i);
  Yg=Yg+Y(i);
  Zg=Zg+Z(i);
end
  Xg=Xg/n;
  Yg=Yg/n;
  Zg=Zg/n;
xg=0;
yg=0;
zg=0;
x=xyzq(:,1)
y=xyzq(:,2)
z=xyzq(:,3:3)
for i=1:n
  xg=xg+x(i);
  yg=yg+y(i);
  zg=zg+z(i);
  end
  xg=xg/n;
  yg=yg/n;
  zg=zg/n;
 zblc=0;
for i=1:n
    Xyh(i)=X(i)-Xg;
    Yyh(i)=Y(i)-Yg;
    Zyh(i)=Z(i)-Zg;
    xyh(i)=x(i)-xg;
    yyh(i)=y(i)-yg;
    zyh(i)=z(i)-zg;                       %重心化坐标
    jl(i)=sqrt(Xyh(i)*Xyh(i)+Yyh(i)*Yyh(i)+Zyh(i)*Zyh(i));
    JL(i)=sqrt(xyh(i)*xyh(i)+yyh(i)*yyh(i)+zyh(i)*zyh(i));
    blc(i)=jl(i)/JL(i);
    zblc=zblc+blc(i);
end
pjblc=zblc/n;     
for i=1:n
    xyhh(i)=pjblc*xyh(i);
    yyhh(i)=pjblc*yyh(i);
    zyhh(i)=pjblc*zyh(i);
end
 dfi0=1;
dom0=1;
dka0=1;
count=0;
while abs(dfi0)>1e-5||abs(dom0)>1e-5||abs(dka0)>1e-5
    count=count+1;
    a10=cos(fi0)*cos(ka0)-sin(fi0)*sin(om0)*sin(ka0);
    a20=-cos(fi0)*sin(ka0)-sin(fi0)*sin(om0)*cos(ka0);
    a30=-sin(fi0)*cos(om0);
    b10=cos(om0)*sin(ka0);
    b20=cos(om0)*cos(ka0);
    b30=-sin(om0);
    c10=sin(fi0)*cos(ka0)+cos(fi0)*sin(om0)*sin(ka0);
    c20=-sin(fi0)*sin(ka0)+cos(fi0)*sin(om0)*cos(ka0);
    c30=cos(fi0)*cos(om0);
    R0=[a10 a20 a30;b10 b20 b30; c10 c20 c30];    
 for i=1:n
    xsjz(3*i-2,1)=1;
    xsjz(3*i-2,2)=0;
    xsjz(3*i-2,3)=0;
    xsjz(3*i-2,4)=xyhh(i);
    xsjz(3*i-2,5)=-zyhh(i);
    xsjz(3*i-2,6)=0;
    xsjz(3*i-2,7)=-yyhh(i);
    xsjz(3*i-1,1)=0;
    xsjz(3*i-1,2)=1;
    xsjz(3*i-1,3)=0;
    xsjz(3*i-1,4)=yyhh(i);
    xsjz(3*i-1,5)=0;
    xsjz(3*i-1,6)=-zyhh(i);
    xsjz(3*i-1,7)=xyhh(i);
    xsjz(3*i,1)=0;
    xsjz(3*i,2)=0;
    xsjz(3*i,3)=1;
    xsjz(3*i,4)=zyhh(i);
    xsjz(3*i,5)=xyhh(i);
    xsjz(3*i,6)=yyhh(i);
    xsjz(3*i,7)=0; 
    ljz(3*i-2)=Xyh(i)-lamda0*[a10 a20 a30]*[xyhh(i);yyhh(i);zyhh(i)]-detX;
    ljz(3*i-1)=Yyh(i)-lamda0*[b10 b20 b30]*[xyhh(i);yyhh(i);zyhh(i)]-detY;
    ljz(3*i)=Zyh(i)-lamda0*[c10 c20 c30]*[xyhh(i);yyhh(i);zyhh(i)]-detZ; 
 end
    dxjz=inv(xsjz'*xsjz)*xsjz'*ljz';
    vjz=-(xsjz*dxjz-ljz');
    detX=detX+dxjz(1);
    detY=detY+dxjz(2);
    detZ=detZ+dxjz(3);
 lamda0=lamda0*(1+dxjz(4));
fi0=fi0+dxjz(5);
om0=om0+dxjz(6);
ka0=ka0+dxjz(7);
dfi0=dxjz(5);
dom0=dxjz(6);
dka0=dxjz(7);
fprintf(fid,'第%d次迭代   %f    %f    %f    %f    %f    %f    %f\r\n\r',count,detX,detY,detZ,fi0,om0,ka0,lamda0);
end
fclose(fid);

%(fid,'%f %f %f %f  \n', xyzq(:,i));
 
end function
\end{lstlisting}

\subsubsection{结果}
\begin{equation}
\begin{array}{lll}
\phi=0.011309 & \omega=0.005634 & \kappa=0.00524 \\
& \lambda=1.00071& \\
dx=0 & dy=0 & dz=0  \\
count=3\\
\end{array}
\end{equation}

\subsection{点误差判断}
\subsubsection{程序}

注：我将点位误差判断与前方交会-绝对定向程序放在了一起。
\begin{lstlisting}
fprintf(fid,'\r\n点名      X                Y             Z             dX         dY         dZ       误差\r\n');
for i=1:n
    XYH(i)=lamda0*[a10 a20 a30]*[xyhh(i);yyhh(i);zyhh(i)]+detX;
    YYH(i)=lamda0*[b10 b20 b30]*[xyhh(i);yyhh(i);zyhh(i)]+detY;
    ZYH(i)=lamda0*[c10 c20 c30]*[xyhh(i);yyhh(i);zyhh(i)]+detZ;%待求点的重心化地面摄影测量坐标
    Xq(i)=XYH(i)+Xg;
    Yq(i)=YYH(i)+Yg;
    Zq(i)=ZYH(i)+Zg;
    xc(i)=Xq(i)-X(i);
    yc(i)=Yq(i)-Y(i);
    zc(i)=Zq(i)-Z(i);
    wuchashi(i)=sqrt(xc(i)*xc(i)+yc(i)*yc(i)+zc(i)*zc(i));
    fprintf(fid,'%d   %f   %f   %f   %f   %f   %f   %f\r\n',i,Xq(i),Yq(i),Zq(i),xc(i),yc(i),zc(i),wuchashi(i));
end
xzwc=sqrt(xc*xc'/(n-1));
yzwc=sqrt(yc*yc'/(n-1));
zzwc=sqrt(zc*zc'/(n-1));
fprintf(fid ,'\r\nX的中误差=%f, Y的中误差=%f, Z的中误差=%f',xzwc,yzwc,zzwc);
fprintf(fid,'\r\n*********************************************分格线***************************************************');
%plot(q);
\end{lstlisting}

\subsubsection{结果}
X的中误差=0.124881, Y的中误差=0.215042, Z的中误差=0.239378

\section{调绘成果}

\begin{figure}[htbp]
\centering
\caption{调绘图概览}
\includegraphics[width=0.9\textwidth]{diaohuijr.jpg}
\end{figure}

\begin{figure}[htbp]
\centering
\caption{调绘图细节}
\includegraphics[width=0.9\textwidth]{diaohui1jr.JPG}
\end{figure}

\section{同名点}


\begin{table}[htbp]
    \centering
    \begin{tabular}{lrrrr}
        \toprule
        & \multicolumn{2}{c}{63} & \multicolumn{2}{c}{64} \\ \hline
        点号 & \multicolumn{1}{c}{i} & \multicolumn{1}{c}{j} & \multicolumn{1}{c}{i} & \multicolumn{1}{c|}{j} \\ \midrule
      20 & 5790 & 2636 & 2630 & 2268 \\
      21 & 5637 & 2737 & 2491 & 2368 \\
      22 & 5669 & 2523 & 2514 & 2150 \\
      23 & 5179 & 2642 & 2014 & 2263 \\
      24 & 5395 & 2448 & 2244 & 2067 \\
      25 & 5475 & 2545 & 2314 & 2169 \\ \bottomrule
    \end{tabular}
    \end{table}
      
